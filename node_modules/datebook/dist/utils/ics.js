"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var FileSaver = require("file-saver");
var data_1 = require("./data");
var time_1 = require("./time");
var safariFileSave_1 = require("./safariFileSave");
var constants_1 = require("../constants");
/**
 * Removes line breaks from a string. Returns an empty string if falsy.
 *
 * @param {string} [str = ''] - string to sanitize
 * @returns {string}
 */
var formatText = function (str) {
    if (str === void 0) { str = ''; }
    return str.replace(/\n/g, '\\n');
};
/**
 * The name of the file will be the event title with alphanumeric chars with the extension `.ics`.
 *
 * @param {string} icsData
 * @returns {Blob}
 */
var getBlob = function (icsData) {
    return new Blob([icsData], {
        type: 'application/octet-stream' // TODO: change to text/calendar?
    });
};
/**
 * Transforms given string to be valid file name.
 *
 * @param {string} title
 * @returns {string}
 */
var getFileName = function (title) {
    if (!title) {
        return 'event.ics';
    }
    return title.replace(/[^\w ]/g, '') + ".ics";
};
/**
 * Returns a random base 36 hash for iCal UID.
 *
 * @returns {string}
 */
var getUid = function () {
    return Math.random().toString(36).substr(2);
};
/**
 * Returns the hostname for usage in `PRODID`. Returns `datebook` in Node.js.
 *
 * @returns {string}
 */
var getProdId = function () {
    return typeof window !== 'undefined'
        ? window.location.host
        : 'datebook';
};
/**
 * Converts the given recurrence options to RFC????
 *
 * @param {CalendarRecurrence} recurrence
 * @returns {string}
 */
var getRrule = function (recurrence) {
    var _a, _b;
    var rrule = {
        FREQ: recurrence.frequency,
        INTERVAL: (_a = recurrence.interval) === null || _a === void 0 ? void 0 : _a.toString(),
        COUNT: (_b = recurrence.count) === null || _b === void 0 ? void 0 : _b.toString(),
        WKST: recurrence.weekstart,
        BYDAY: recurrence.weekdays,
        BYMONTHDAY: recurrence.monthdays
    };
    if (recurrence.end) {
        rrule.UNTIL = time_1.default.formatDate(recurrence.end, constants_1.FORMAT.FULL);
    }
    return data_1.default.toIcsParamString(rrule);
};
/**
 * Returns true if the current browser is Safari.
 *
 * @returns {boolean}
 */
var isSafari = function () {
    return window.hasOwnProperty('safari') || (
    // check to ensure navigator is not Chrome (which includes Safari in the user agent)
    /^((?!chrome|android).)*safari/i.test(navigator.userAgent) &&
        // browsers on iOS are wrappers around Safari, but include CriOS (Chrome), FxiOS (Firefox), etc.
        !/(cr|fx)ios[^a-z]/i.test(navigator.userAgent));
};
/**
 * Downloads the given ics as an iCalendar file.
 *
 * @param {string} fileName - filename of the event file
 * @param {string} data - ics data
 */
var download = function (fileName, data) {
    if (isSafari()) {
        safariFileSave_1.default(data, fileName);
    }
    else {
        var blob = getBlob(data);
        FileSaver.saveAs(blob, fileName);
    }
};
exports.default = {
    formatText: formatText,
    getBlob: getBlob,
    getFileName: getFileName,
    getUid: getUid,
    getProdId: getProdId,
    getRrule: getRrule,
    download: download
};
